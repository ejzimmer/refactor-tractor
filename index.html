<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Getting on the Refactor Tractor</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">
		<link rel="stylesheet" href="css/fonts.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<script src="js/reveal.js"></script>

		<style>
			* {
				box-sizing: border-box;
			}

			body {
				--dark-blue: hsl(202, 69%, 15%);
				--light-blue: #15A9DD;
				--light-orange: hsl(19, 87%, 62%);
				--dark-orange: hsl(24, 100%, 38%);
				--light-red: hsl(0, 94%, 41%);
				--red: #7B0001;
				--shadow: hsl(202, 69%, 15%, .4);
				--green: hsl(125, 94%, 41%);
				--dark-green: hsl(125 94% 20%);
				--gradient-start: hsl(259, 71%, 80%);
				--gradient-end: hsl(265, 58%, 50%);
				--yellow: #F2E34B;
			}

			.notes {
				display: none;
			}
			pre, .browser {
				-moz-tab-size: 2;
				border: 4px solid hsl(200, 10%, 55%);
				border-top-width: 32px;
				border-radius: 10px;
				padding: .5em;
				background: #272822;
				box-shadow:
					inset 2px 2px 1px black,
					4px 4px 8px hsla(0, 0%, 20%, .3);
				align-self: center;
			}
			pre code {
				border-radius: 10px;
				height: 100%;
			}

			h1 {
				font-size: 60px;
			}

			ul {
				list-style-type: '\1f680';
			}
			li {
				margin: .75em 0;
				padding-left: .5em;
			}

			.shadow {
				box-shadow: 1px 1px 4px hsla(0, 0%, 70%), 3px 3px 6px hsla(0, 0%, 70%);
			}

			.reveal .slides > section.auto-height {
				height: auto;
			}

			.fragment.transient {
				display: none;
			}
			.fragment.transient.current-fragment {
				display: block;
			}

		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

				<section class="title"  data-background-size="contain" data-background-position="-150px 0">
					<h1>Getting on the refactor tractor</h1>
				</section>

				<section class="intro">
					<style>
						.intro {
							grid-template-rows: min-content min-content 60%;
							align-content: center;
						}
						.intro a {
							text-align: left;
							align-self: center;
							font-weight: bold;
						}
						.intro .zoidberg {
							position: fixed;
							left: 644px;
							top: 379px;
							border-radius: 62% 38% 63% 37% / 73% 52% 48% 27%;
						}

						.intro .logos {
							list-style: none;
							display: grid;
							grid-template-columns: 1fr 1fr;
							max-width: 60%;
							margin: 0;
							grid-gap: 40px;
							align-items: center;
						}
						.intro .logos li {
							margin: 0;
						}
					</style>
					<div style="justify-self: left; font-family: Futurama;">@ErinJZimmer</div>
					<a href="https://layouts.ez.codes">https://layouts.ez.codes</a>
					<ul class="logos">
						<li><img src="images/cogent-logo.svg" alt=""></li>
						<li><img src="images/gde-logo.png"></li>
					</ul>
					<img class="zoidberg" src="images/zoidberg-knitting.gif" alt="">
				</section>

				<section>what is refactoring? </section>

				<section>
					example of IDE refactoring code
					splitting class or function into smaller pieces 
					renaming things 
					moving repeated code into reusable functions 
					mention the refactoring book and its long index of refactors 
				</section>

				<section>
					when to refactor?
					everything is tradeoffs
					refactoring is very satisfying and can provide a lot of value
					- faster development (easier to work in parallel, get people up to speed faster, easier to understand code)
					- more confidence because it's easier to understand the code, easier to have better test coverage
					but there are downsides

					put the damn socialite time period picker code
				</section>

				<section>
					refactoring is inherently risky - you might break something
					<img src="images/refactor-haiku.png" />
					<a href="https://twitter.com/erinfranmc/status/1182313928539418624">https://twitter.com/erinfranmc/status/1182313928539418624</a>
					<div class="notes">
						no doubt this woman on twitter received a million recommendations of how she should have done better testing or something
						but refactoring is inherently risky
						not just that you can break stuff
						you might inadvertedently change some behaviour (eg it might have been broken and you might accidently fix it)
						changes can surprise users, might even break workflows
					</div>
				</section>

				<section>
					or you might fix something! 
					unexpected change can be bad, depending on your product/industry
				</section>

				<section>
					refactoring isn't free 
					is there something more valuable you could be doing with your time? 
					a day of refactoring is nice for you, but the users don't notice it
				</section>

				<section>
					there's no magic answer - you have to weigh up the risks, cost and value yourself
					as a rule though, i only refactor code that i'm either touching immediately, or that 
					i know someone is going to touch very soon 
					ie the value is certain
					scrolled past the damn socialite code for 2 months without refactoring it because 
					it worked, and there was no value in changing it
				</section>

				<section>
					so you've decided to refactor

					you've spent 3 days fighting bugs because you keep forgetting moment dates are mutable 
					the library was deprecated x years ago and is probably full of security issues
					it's time to replace it with dayjs 

					value is high - date stuff is going to be easier in the future + security patches whatever 
					cost is relatively low because this codebase has wrapper functions around the calls to 
					format, so we only need to change half a dozen wrapper functions instead of updating every single 
					date in the app!
				</section>

				<section>
					the date function

					so how do we manage the risk?
				</section>

				<section>
					1. use testing to determine the current behaviour of the system 
					2. do the refactor, using the tests to ensure the behaviour doesn't change 
					3. make changes (in this case nothing - the refactor is the entire point)
				</section>

				<section>
					use a special kind of test: characterisation tests. whathisname and his book.
					even if your codebase already has good test coverage, you might want to consider adding 
					some characterisation tests
					if your codebase doesn't have good test coverage, you definitely want some of these.
				</section>

				<section>
					characterisation tests
					<div class="notes">
						put the shine effect on this for surprise
						and put a reference in to the book
						also probably read the book
						also maybe mention that we're talking about a code base where the test coverage isn't 100%
					</div>
				</section>

				<section>
					- assume the code is correct. DON'T CHANGE THE CODE
					- use tests to determine what the actual behaviour of the code is`
					- then the tests form documentation of the code yay
				</section>

				<section>
					<pre><code>
import format from 'date-fns/format';

export const formatShortDate = (timestamp: number | string = ''): string => {
	if (!timestamp) {
		return '';
	}

	return format(new Date(timestamp), 'yyyy-MM-d');
};						
					</code></pre>
					<div class="notes">
						go to live code example

						but would you really do all this?
						- it depends
						- it's a small bit of code, so it might be easier to just think it through
						- dates are tricky & this was easier than going through the dayjs docs
						- how much effort are the tests and how big is the risk of changing?
					</div>
				</section>

				<section>
					What about JSX?
				</section>

				<section>
					<pre><code>
function DayOfTheWeekWidget({ date = '' }: { date?: string | number }) {
	if (!date) {
		return <div>No date entered</div>
	}

	const formattedDate = formatShortDate(date)
	const dayOfTheWeek = format(new Date(date), 'EEEE')

	return <div>{formattedDate} is a {dayOfTheWeek}</div>
}						
					</code></pre>
					<div class="notes">
						- imagine we've got the same thing, but in a component 
						- two options: normal tests or snapshot tests

						- normal tests demo
					</div>
				</section>

				<section>
					Snapshot Tests 
				</section>

				<section>
					<pre><code>
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`DayOfTheWeekWidget renders ?? when passed an empty string 1`] = `
<div>
	<div>
		No date entered
	</div>
</div>
`;
</code></pre>
					<div class="notes">
						- first run: create snapshot 
						- subsequent runs, compare to snapshot

						Demo 
						- write snapshot tests 
						- show snapshot being written & in folder
						- refactor to dayjs (new format is 'dddd')
					</div>
				</section>

				<section>
					snapshot tests cautionary tale 
				</section>

				<section>
					when snapshot tests aren't going to work

					embed the example here so i can demo the enter + space
				</section>

				<section>
					Snapshot tests 
						- when the HTML isn't going to change 

					Query tests 
						- when the HTML is going to change
						- when testing behaviour not reflected in HTML
				</section>

				<section>
					intro to big example
				</section>

				<section>
					new requirements!

					Add stocks to payment type radio buttons
Change label of amount field to show stocks + stocks limit
Donâ€™t do currency conversion when stocks amount is updated
Show stocks limit in maximum amount per payment switch
Show calendar year amount override switch in USD
Call new stocks API
Update amount paid in session to also show stocks
Donâ€™t show the BTC conversion widget when stocks are selected

<div class="notes">
	this is a pretty hefty bit of work that we probably don't want to do all in one go 
	could use a feature flag to hide the new radio button while we develop everything else
	but this is a 45-minute talk, ain't got no time for feature flags, we're just going to start by
	building the second thing, and rely on our automated tests to tell us if we've got things right, 
	rather than testing locally in an actual browser
</div>
				</section>

				<section>
					updated label needs to look like
					Stocks Amount <amount in input> (min $<stocks min>, max $<stocks max>)
<div class="notes">
	we can implement this and be pretty sure that it's going to look ok, without needing to actually look at it
	but...
</div>
				</section>

				<section>
					...the current code looks like ... 
					separate labels for each option. actually maybe even separate inputs
					<div class="notes">
						it's relying on bits of state from all over the component
						how are we going to test it without writing the radio button part first?
					</div>
				</section>

				<section>
					Create a new component!
					<pre><code>
						export default function AmountLabel({currency, amount, minAmount, maxAmount}: Props) {
  
							...
					 
						return <label htmlFor="amount">{currency} Amount {amount} (min {minAmount}, max {maxAmount})</label>
					 
					 }
					 
					</code></pre>
					<div class="notes">
						creating a whole new component feels like a risky change though, so how do we do it safely?
					</div>
				</section>

				<section>
					1. write characterisation tests for current behaviour of the label
					2. refactor into a new label component, and ensure the behaviour is unchanged
					3. write tests for our new functionality
					4. write the new functionality
				</section>

				<section>
					Step 1. Test the existing functionality
					<pre><code>
it('shows Â¯\\_(ãƒ„)_/Â¯ when the currency is USD', ...)
it('shows Â¯\\_(ãƒ„)_/Â¯ when the currency is Bitcoin', ...)
it('shows Â¯\\_(ãƒ„)_/Â¯ when the amount changes', ...)
it('show Â¯\\_(ãƒ„)_/Â¯ when the upper limit changes', ...)
					</code></pre>

				</section>

				<section>
					Step 2. Extract the functionality into a component
					<pre><code>
						<AmountLabel
 currency={this.state.currency}
 amount={this.state.amount}
 minAmount={LOWER_LIMIT[this.state.currency]}
 maxAmount={this.state.upperLimit}
/>

					</code></pre>
				</section>

				<section>
					Step 2 (cont). Extract the functionality into a component
					<pre><code>
						export default function AmountLabel({currency, amount, lowerLimit, upperLimit}: Props) {
							const getLabelText = (): string => {
								switch (currency) {
									case PayoutCurrency.USD:
										return `USD Amount ${amount.toLocaleString()} (min $${lowerLimit}, max $${upperLimit})`
									case PayoutCurrency.BTC:
										return `Satoshi Amount ${formatNumber(amount)} (min ${formatNumber(
											lowerLimit
										)} satoshi, max ${formatNumber(upperLimit)} satoshi)`
									default:
										return "Amount"
								}
							}
						 
							return <label htmlFor="amount">{getLabelText()}</label>
						 
						 }
						 
					</code></pre>
				</section>

				<section>
					Step 3a. Write tests for our new functionality.

					Maybe we want to refactor our existing tests a bit first
				</section>

				<section>
					Step 3b. Actually write our tests
				</section>

				<section>
					Step 4. Add the new functionality
				</section>

				<section>
Add stocks to payment type radio buttons
<s>Change label of amount field to show stocks + stocks limit</s>
Donâ€™t do currency conversion when stocks amount is updated
Show stocks limit in maximum amount per payment switch
Show calendar year amount override switch in USD
Call new stocks API
Update amount paid in session to also show stocks
Donâ€™t show the BTC conversion widget when stocks are selected

					<div class="notes">
						sweet, so that's one thing crossed off the list
						the next thing literally says _don't_ do a thing, so we shouldn't have to do anything, right?
					</div>
				</section>

				<section>
					<pre><code>
						private convertAmountCents(
 amountCents: number,
 sourceCurrency: string,
 convertedAmountCents: { [customerRegion: string]: number }
) {
 // Do not send request when amountCents == 0
 if (amountCents == 0) {
   for (const customerRegion in convertedAmountCents) {
     convertedAmountCents[customerRegion] = 0
   }
   this.setState({
     convertedAmountCents: convertedAmountCents
   })
   return
 }

 // Do not send request when currency == BTC
 if (sourceCurrency == "BTC") return
					</code></pre>
					<div class="notes">
						the code checks for BTC and returns early, rather than checking for the existence of USD and doing the thing
					</div>
				</section>

				<section>
					<pre><code>if (sourceCurrency == "BTC" || sourceCurrency == "STOCKS") return</code></pre>
					<div class="notes">
						we could just add stocks to the btc check and be done with it
						and, if we were in a hurry, maybe that's what we would do
						but i like my code tested!
					</div>
				</section>

				<section>
<pre><code>
	<NumericInput 
		onValueChange={this.handleAmountChange}
		min={0}
		placeholder={"0"}
		allowNumericCharactersOnly={true}
		minorStepSize={null}
		buttonPosition={"none"}
		fill={true}
	/>
	{!this.isAmountValid(this.state.amountCents) && (
		<label style={{ color: Colors.RED3 }}>Invalid Amount</label>
	)}
	{this.state.currency != "BTC" && 
		this.state.convertedAmountCents.GBP >= 0 && (
			<label style={{ color: Colors.GREEN3 }}>wavy equals pound sign{this.state.convertedAmountCents.GBP / 100}</label>
		)
	{this.state.currency != "BTC" && 
		this.state.convertedAmountCents.GBP < 0 && (
			<label style={{ color: Colors.RED3 }}>
				Failed to convert amount to GBP, will pay UK customers in USD!
			</label>
		)}
	)}
</code></pre>
					<div class="notes">
						and this != BTC check actually happens in quite a few places, so it would be nice to clean it up a bit
					</div>
				</section>

				<section>
					go through same process 
					characterisation tests, extract to component, refactor tests, add new functionality
				</section>

				<section>
					characterisation tests
				</section>

				<section>
					extract to component, that will look something like 
					<pre><code>
						<AmountInput currency={} minAmount={} maxAmount={} handleAmountUpdate={} />
					</code></pre>
					and if we think back to what we just did, we made a component like
					<pre><code>
						<AmountLabel
						currency={this.state.currency}
						amount={this.state.amount}
						minAmount={LOWER_LIMIT[this.state.currency]}
						maxAmount={this.state.upperLimit}
					 />
					 
					</code></pre> 
					and those are pretty similar
					something something single responsibility principle
					yadda yadda one reason to change 
					these should be the same component
				</section>

				<section>
					there's actually a fairly big chunk involved in moving this stuff
					so should probably go through it step by step
				</section>

				<section>
					when refactoring the tests, don't forget that we need to test that 
					the handler gets called
				</section>

				<section>
					What did we learn?
					- refactor code when we're touching it
					- use characterisation tests to ensure we don't change functionality
					- extract functionality into components to isolate and test 
					- group similar concerns into components

				</section>

				<section class="end">
					<style>
						.end {
							font-family: Futurama;
							align-items: center;
						}

						.end .bender {
							position: fixed;
						}
					</style>

					<div class="fragment"><a href="https://refactor.ez.codes">https://refactor-tractor.ez.codes</a></div>	

					<div class="fragment">
						<div>@ErinJZimmer</div>
						<div>Thank you!</div>
					</div>


					<img src="images/bender-applause.png" alt="bender holding applause sign" class="bender fragment">
				</section>
			</div>
		</div>

		<div style="position: fixed; bottom: 30px; right: 30px; font-family: Futurama; font-size: 36px; opacity: .6; z-index: 1">
			@ErinJZimmer
		</div>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				controls: false,
				history: true,
				display: 'grid',
				progress: false,
				transition: 'fade',
				center: false,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});

		</script>
	</body>
</html>
