<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Getting on the Refactor Tractor</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">
		<link rel="stylesheet" href="css/fonts.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<script src="js/reveal.js"></script>

		<style>
			* {
				box-sizing: border-box;
			}

			body {
				--dark-blue: hsl(202, 69%, 15%);
				--light-blue: #15A9DD;
				--light-orange: hsl(19, 87%, 62%);
				--dark-orange: hsl(24, 100%, 38%);
				--light-red: hsl(0, 94%, 41%);
				--red: #7B0001;
				--shadow: hsl(202, 69%, 15%, .4);
				--green: hsl(125, 94%, 41%);
				--dark-green: hsl(125 94% 20%);
				--gradient-start: hsl(259, 71%, 80%);
				--gradient-end: hsl(265, 58%, 50%);
				--yellow: #F2E34B;
			}

			.notes {
				display: none;
			}
			pre, .browser {
				-moz-tab-size: 2;
				border: 4px solid hsl(200, 10%, 55%);
				border-top-width: 32px;
				border-radius: 10px;
				padding: .5em;
				background: #272822;
				box-shadow:
					inset 2px 2px 1px black,
					4px 4px 8px hsla(0, 0%, 20%, .3);
				align-self: center;
			}
			pre code {
				border-radius: 10px;
				height: 100%;
			}

			h1 {
				font-size: 60px;
			}

			ul {
				list-style-type: '\1f680';
			}
			li {
				margin: .75em 0;
				padding-left: .5em;
			}

			.shadow {
				box-shadow: 1px 1px 4px hsla(0, 0%, 70%), 3px 3px 6px hsla(0, 0%, 70%);
			}

			.reveal .slides > section.auto-height {
				height: auto;
			}

			.fragment.transient {
				display: none;
			}
			.fragment.transient.current-fragment {
				display: block;
			}

		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

				<section class="title"  data-background-size="contain" data-background-position="-150px 0">
					<h1>Getting on the refactor tractor</h1>
				</section>

				<section class="intro">
					<style>
						.intro {
							grid-template-rows: min-content min-content 60%;
							align-content: center;
						}
						.intro a {
							text-align: left;
							align-self: center;
							font-weight: bold;
						}
						.intro .zoidberg {
							position: fixed;
							left: 644px;
							top: 379px;
							border-radius: 62% 38% 63% 37% / 73% 52% 48% 27%;
						}

						.intro .logos {
							list-style: none;
							display: grid;
							grid-template-columns: 1fr 1fr;
							max-width: 60%;
							margin: 0;
							grid-gap: 40px;
							align-items: center;
						}
						.intro .logos li {
							margin: 0;
						}
					</style>
					<div style="justify-self: left; font-family: Futurama;">@ErinJZimmer</div>
					<a href="https://layouts.ez.codes">https://layouts.ez.codes</a>
					<ul class="logos">
						<li><img src="images/cogent-logo.svg" alt=""></li>
						<li><img src="images/gde-logo.png"></li>
					</ul>
					<img class="zoidberg" src="images/zoidberg-knitting.gif" alt="">
				</section>

				<section>what is refactoring? </section>

				<section>
					example of IDE refactoring code
					splitting class or function into smaller pieces 
					renaming things 
					moving repeated code into reusable functions 
					mention the refactoring book and its long index of refactors 
				</section>

				<section>
					when to refactor?
					everything is tradeoffs
					refactoring is very satisfying and can provide a lot of value
					- faster development (easier to work in parallel, get people up to speed faster, easier to understand code)
					- more confidence because it's easier to understand the code, easier to have better test coverage
					but there are downsides

					put the damn socialite time period picker code
				</section>

				<section>
					refactoring is inherently risky - you might break something
					<img src="images/refactor-haiku.png" />
					<a href="https://twitter.com/erinfranmc/status/1182313928539418624">https://twitter.com/erinfranmc/status/1182313928539418624</a>
					<div class="notes">
						no doubt this woman on twitter received a million recommendations of how she should have done better testing or something
						but refactoring is inherently risky
						not just that you can break stuff
						you might inadvertedently change some behaviour (eg it might have been broken and you might accidently fix it)
						changes can surprise users, might even break workflows
					</div>
				</section>

				<section>
					or you might fix something! 
					unexpected change can be bad, depending on your product/industry
				</section>

				<section>
					refactoring isn't free 
					is there something more valuable you could be doing with your time? 
					a day of refactoring is nice for you, but the users don't notice it
				</section>

				<section>
					there's no magic answer - you have to weigh up the risks, cost and value yourself
					as a rule though, i only refactor code that i'm either touching immediately, or that 
					i know someone is going to touch very soon 
					ie the value is certain
					scrolled past the damn socialite code for 2 months without refactoring it because 
					it worked, and there was no value in changing it
				</section>

				<section>
					so you've decided to refactor

					you've spent 3 days fighting bugs because you keep forgetting moment dates are mutable 
					the library was deprecated x years ago and is probably full of security issues
					it's time to replace it with dayjs 

					value is high - date stuff is going to be easier in the future + security patches whatever 
					cost is relatively low because this codebase has wrapper functions around the calls to 
					format, so we only need to change half a dozen wrapper functions instead of updating every single 
					date in the app!
				</section>

				<section>
					the date function

					so how do we manage the risk?
				</section>

				<section>
					1. use testing to determine the current behaviour of the system 
					2. do the refactor, using the tests to ensure the behaviour doesn't change 
					3. make changes (in this case nothing - the refactor is the entire point)
				</section>

				<section>
					use a special kind of test: characterisation tests. whathisname and his book.
					even if your codebase already has good test coverage, you might want to consider adding 
					some characterisation tests
					if your codebase doesn't have good test coverage, you definitely want some of these.
				</section>

				<section>
					normal test. 
					invariable behaviour encoded in test 
					write code until the test passes 

					or, if you don't do TDD
					write some code 
					write your test 
					go back and change your code until the test passes 
					consider your life choices and how much time you would have saved if you just wrote the test first 
				</section>

				<section>
					characterisation test 
					invariable behaviour encoded in code 
					change the tests until they pass 

					do the live code example 
					you'll have to decide what to do about the difference in behaviour between the libraries

					but would you really do all this?
					- it depends
					- it's a small bit of code, so it might be easier to just think it through
					- dates are tricky & this was easier than going through the dayjs docs
					- how much effort are the tests and how big is the risk of changing?
				</section>

				<section>
					What about JSX?
				</section>

				<section>
					<pre><code>
function DayOfTheWeekWidget({ date = '' }: { date?: string | number }) {
	if (!date) {
		return <div>No date entered</div>
	}

	const formattedDate = formatShortDate(date)
	const dayOfTheWeek = format(new Date(date), 'dddd')

	return <div>{formattedDate} is a {dayOfTheWeek}</div>
}
											</code></pre>
					<div class="notes">
						- continuing with our moment to dayjs refactor, we can take the same approach as before...
					</div>
				</section>

				<section>
					Snapshot Tests 
				</section>

				<section>
					<pre><code>
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`DayOfTheWeekWidget renders ?? when passed an empty string 1`] = `
<div>
	<div>
		No date entered
	</div>
</div>
`;
</code></pre>
					<div class="notes">
						- first run: create snapshot 
						- subsequent runs, compare to snapshot

						Demo 
						- write snapshot tests 
						- show snapshot being written & in folder
						- refactor to dayjs (new format is 'dddd')
					</div>
				</section>

				<section>
					snapshot tests cautionary tale 
				</section>

				<section>
					when snapshot tests aren't going to work

					embed the example here so i can demo the enter + space
				</section>

				<section>
					<div>
						<button id="open-modal">Open modal</button>
						<div id="modal" style="opacity: 0">
							<p>Can we fix it?</p>
							<div>
								<button id="confirm-button" onClick={onConfirm}>Yes, we can!</button>
								<a id="cancel-button" onClick={handleCancel} onKeyDown={handleSpace} href="#">No, we can't</a>
							</div>
						</div>
						<script>
							const openModal = document.getElementById('open-modal')
							const modal = document.getElementById('modal')
							const confirmButton = document.getElementById('confirm-button')
							const cancelButton = document.getElementById('cancel-button')

							openModal.addEventListener('click', () => {	
								modal.style.opacity = 1
							})
							confirmButton.addEventListener('click', () => {
								modal.style.opacity = 0
							})
							cancelButton.addEventListener('click', (event) => {
								modal.style.opacity = 0
								event.preventDefault()
							})
						</script>	
					</div>
				</section>

				<section>
<pre><code class="jsx">
	export function ConfirmationModal({ onConfirm, onCancel }) {
	
		const handleCancel = (event) => {
			event.preventDefault();
			onCancel();	
		}
	
		const handleSpace = (event) => {
			const keyPressed = event.code
			if (keyPressed === 'Space') {
				handleCancel(event);
			}
		}
		
		return (
			<div>
				<p>Can we fix it?</p>
				<div>
					&lt;button onClick={onConfirm}>Yes, we can!</button>
					&lt;a
						onClick={handleCancel} 
						onKeyDown={handleSpace} 
						href="#"
					&gt;No, we can't</a>
				</div>
			</div>
		)
	}					
</code></pre>
				<div class="notes">
					- look at example with snapshot test 
					problems
						- we need to change the HTML, which is going to cause the snapshot test to fail
						- its only testing the render, not the actual behaviour
						- can't test the behaviour because it's not causing the render to change 
					outcome
						- use query tests to test behaviour 
						- use correct semantic HTML and throw out a heap of code & tests
						  (we don't need tests when we use semantic HTML because we meet the standard 
							by default. if the standard changes, the behaviour of our app will too, which 
							is what we want. but also, the behaviour will just work in unknown media eg 
							touch screens, non-standard inputs)
				</div>				
				</section>

				<section>
					the refactored code but we'll need to put in the styling to make it match
				</section>

				<section>
					Snapshot tests 
						- when the HTML isn't going to change 

					Query tests 
						- when the HTML is going to change
						- when testing behaviour not reflected in HTML
				</section>

				<section>
					intro to ye olde farm shop
					but go on, put a thorn in and explain the y thing
				</section>

				<section>
					new requirements!

					- Add plant product type to radio buttons
					- Show plant unit price + total price in label 
					- Calculate postage for plants
<div class="notes">
	- not a huge bit of work, but it's nice to be able to break it down, especially as we'll need to write 
		some tests to cover the existing behaviour and the PR could get quite big 
	- instead we'll do each step individually, but not in the order they're given here: the new radio button 
	  relies on the other two things, so we can't merge it until those are complete, so let's do the other two 
		first
</div>
				</section>

				<section>
					1. Show plant unit price + total price in label 
					2. Calculate postage for plants 
					3. Add new radio button
				</section>

				<section>
					updated label needs to look like
					Stocks Amount <amount in input> (min $<stocks min>, max $<stocks max>)
<div class="notes">
	we can implement this and be pretty sure that it's going to look ok, without needing to actually look at it
	but...
</div>
				</section>

				<section>
					...the current code looks like ... 
					separate labels for each option. actually maybe even separate inputs
					<div class="notes">
						it's relying on bits of state from all over the component
						how are we going to test it without writing the radio button part first?
					</div>
				</section>

				<section>
					Create a new component!
					<pre><code>
						export default function AmountLabel({currency, amount, minAmount, maxAmount}: Props) {
  
							...
					 
						return <label htmlFor="amount">{currency} Amount {amount} (min {minAmount}, max {maxAmount})</label>
					 
					 }
					 
					</code></pre>
					<div class="notes">
						creating a whole new component feels like a risky change though, so how do we do it safely?
					</div>
				</section>

				<section>
					1. write characterisation tests for current behaviour of the label
					2. refactor into a new label component, and ensure the behaviour is unchanged
					3. write tests for our new functionality
					4. write the new functionality
				</section>

				<section>
					Step 1. Test the existing functionality
					<pre><code>
it('shows ¯\\_(ツ)_/¯ when the currency is USD', ...)
it('shows ¯\\_(ツ)_/¯ when the currency is Bitcoin', ...)
it('shows ¯\\_(ツ)_/¯ when the amount changes', ...)
it('show ¯\\_(ツ)_/¯ when the upper limit changes', ...)
					</code></pre>

				</section>

				<section>
					Step 2. Extract the functionality into a component
					<pre><code>
						<AmountLabel
 currency={this.state.currency}
 amount={this.state.amount}
 minAmount={LOWER_LIMIT[this.state.currency]}
 maxAmount={this.state.upperLimit}
/>

					</code></pre>
				</section>

				<section>
					Step 2 (cont). Extract the functionality into a component
					<pre><code>
						export default function AmountLabel({currency, amount, lowerLimit, upperLimit}: Props) {
							const getLabelText = (): string => {
								switch (currency) {
									case PayoutCurrency.USD:
										return `USD Amount ${amount.toLocaleString()} (min $${lowerLimit}, max $${upperLimit})`
									case PayoutCurrency.BTC:
										return `Satoshi Amount ${formatNumber(amount)} (min ${formatNumber(
											lowerLimit
										)} satoshi, max ${formatNumber(upperLimit)} satoshi)`
									default:
										return "Amount"
								}
							}
						 
							return <label htmlFor="amount">{getLabelText()}</label>
						 
						 }
						 
					</code></pre>
				</section>

				<section>
					Step 3a. Write tests for our new functionality.

					Maybe we want to refactor our existing tests a bit first
				</section>

				<section>
					Step 3b. Actually write our tests
				</section>

				<section>
					Step 4. Add the new functionality
				</section>

				<section>
Add stocks to payment type radio buttons
<s>Change label of amount field to show stocks + stocks limit</s>
Don’t do currency conversion when stocks amount is updated
Show stocks limit in maximum amount per payment switch
Show calendar year amount override switch in USD
Call new stocks API
Update amount paid in session to also show stocks
Don’t show the BTC conversion widget when stocks are selected

					<div class="notes">
						sweet, so that's one thing crossed off the list
						the next thing literally says _don't_ do a thing, so we shouldn't have to do anything, right?
					</div>
				</section>

				<section>
					<pre><code>
						private convertAmountCents(
 amountCents: number,
 sourceCurrency: string,
 convertedAmountCents: { [customerRegion: string]: number }
) {
 // Do not send request when amountCents == 0
 if (amountCents == 0) {
   for (const customerRegion in convertedAmountCents) {
     convertedAmountCents[customerRegion] = 0
   }
   this.setState({
     convertedAmountCents: convertedAmountCents
   })
   return
 }

 // Do not send request when currency == BTC
 if (sourceCurrency == "BTC") return
					</code></pre>
					<div class="notes">
						the code checks for BTC and returns early, rather than checking for the existence of USD and doing the thing
					</div>
				</section>

				<section>
					<pre><code>if (sourceCurrency == "BTC" || sourceCurrency == "STOCKS") return</code></pre>
					<div class="notes">
						we could just add stocks to the btc check and be done with it
						and, if we were in a hurry, maybe that's what we would do
						but i like my code tested!
					</div>
				</section>

				<section>
<pre><code>
	<NumericInput 
		onValueChange={this.handleAmountChange}
		min={0}
		placeholder={"0"}
		allowNumericCharactersOnly={true}
		minorStepSize={null}
		buttonPosition={"none"}
		fill={true}
	/>
	{!this.isAmountValid(this.state.amountCents) && (
		<label style={{ color: Colors.RED3 }}>Invalid Amount</label>
	)}
	{this.state.currency != "BTC" && 
		this.state.convertedAmountCents.GBP >= 0 && (
			<label style={{ color: Colors.GREEN3 }}>wavy equals pound sign{this.state.convertedAmountCents.GBP / 100}</label>
		)
	{this.state.currency != "BTC" && 
		this.state.convertedAmountCents.GBP < 0 && (
			<label style={{ color: Colors.RED3 }}>
				Failed to convert amount to GBP, will pay UK customers in USD!
			</label>
		)}
	)}
</code></pre>
					<div class="notes">
						and this != BTC check actually happens in quite a few places, so it would be nice to clean it up a bit
					</div>
				</section>

				<section>
					go through same process 
					characterisation tests, extract to component, refactor tests, add new functionality
				</section>

				<section>
					characterisation tests
				</section>

				<section>
					extract to component, that will look something like 
					<pre><code>
						<AmountInput currency={} minAmount={} maxAmount={} handleAmountUpdate={} />
					</code></pre>
					and if we think back to what we just did, we made a component like
					<pre><code>
						<AmountLabel
						currency={this.state.currency}
						amount={this.state.amount}
						minAmount={LOWER_LIMIT[this.state.currency]}
						maxAmount={this.state.upperLimit}
					 />
					 
					</code></pre> 
					and those are pretty similar
					something something single responsibility principle
					yadda yadda one reason to change 
					these should be the same component
				</section>

				<section>
					there's actually a fairly big chunk involved in moving this stuff
					so should probably go through it step by step
				</section>

				<section>
					when refactoring the tests, don't forget that we need to test that 
					the handler gets called
				</section>

				<section>
					What did we learn?
					- refactor code when we're touching it
					- use characterisation tests to ensure we don't change functionality
					- extract functionality into components to isolate and test 
					- group similar concerns into components

				</section>

				<section class="end">
					<style>
						.end {
							font-family: Futurama;
							align-items: center;
						}

						.end .bender {
							position: fixed;
						}
					</style>

					<div class="fragment"><a href="https://refactor.ez.codes">https://refactor-tractor.ez.codes</a></div>	

					<div class="fragment">
						<div>@ErinJZimmer</div>
						<div>Thank you!</div>
					</div>


					<img src="images/bender-applause.png" alt="bender holding applause sign" class="bender fragment">
				</section>
			</div>
		</div>

		<div style="position: fixed; bottom: 30px; right: 30px; font-family: Futurama; font-size: 36px; opacity: .6; z-index: 1">
			@ErinJZimmer
		</div>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				controls: false,
				history: true,
				display: 'grid',
				progress: false,
				transition: 'fade',
				center: false,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});

		</script>
	</body>
</html>
