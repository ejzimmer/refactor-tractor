<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Getting on the Refactor Tractor</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">
		<link rel="stylesheet" href="css/fonts.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<script src="js/reveal.js"></script>

		<style>
			* {
				box-sizing: border-box;
			}

			body {
				--dark-blue: hsl(202, 69%, 15%);
				--light-blue: #15A9DD;
				--light-orange: hsl(19, 87%, 62%);
				--dark-orange: hsl(24, 100%, 38%);
				--light-red: hsl(0, 94%, 41%);
				--red: #7B0001;
				--shadow: hsl(202, 69%, 15%, .4);
				--green: hsl(125, 94%, 41%);
				--dark-green: hsl(125 94% 20%);
				--gradient-start: hsl(259, 71%, 80%);
				--gradient-end: hsl(265, 58%, 50%);
				--yellow: #F2E34B;
			}

			.notes {
				display: none;
			}
			pre, .browser {
				-moz-tab-size: 2;
				border: 4px solid hsl(200, 10%, 55%);
				border-top-width: 32px;
				border-radius: 10px;
				padding: .5em;
				background: #272822;
				box-shadow:
					inset 2px 2px 1px black,
					4px 4px 8px hsla(0, 0%, 20%, .3);
				align-self: center;
			}
			pre code {
				border-radius: 10px;
				height: 100%;
			}

			h1 {
				font-size: 60px;
			}

			ul {
				list-style-type: '\1f680';
			}
			li {
				margin: .75em 0;
				padding-left: .5em;
			}

			.shadow {
				box-shadow: 1px 1px 4px hsla(0, 0%, 70%), 3px 3px 6px hsla(0, 0%, 70%);
			}

			.reveal .slides > section.auto-height {
				height: auto;
			}

			.fragment.transient {
				display: none;
			}
			.fragment.transient.current-fragment {
				display: block;
			}

		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

				<section class="title"  data-background-size="contain" data-background-position="-150px 0">
					<h1>Getting on the refactor tractor</h1>
				</section>

				<section class="intro">
					<style>
						.intro {
							grid-template-rows: min-content min-content 60%;
							align-content: center;
						}
						.intro a {
							text-align: left;
							align-self: center;
							font-weight: bold;
						}
						.intro .zoidberg {
							position: fixed;
							left: 644px;
							top: 379px;
							border-radius: 62% 38% 63% 37% / 73% 52% 48% 27%;
						}

						.intro .logos {
							list-style: none;
							display: grid;
							grid-template-columns: 1fr 1fr;
							max-width: 60%;
							margin: 0;
							grid-gap: 40px;
							align-items: center;
						}
						.intro .logos li {
							margin: 0;
						}
					</style>
					<div style="justify-self: left; font-family: Futurama;">@ErinJZimmer</div>
					<a href="https://layouts.ez.codes">https://layouts.ez.codes</a>
					<ul class="logos">
						<li><img src="images/cogent-logo.svg" alt=""></li>
						<li><img src="images/gde-logo.png"></li>
					</ul>
					<img class="zoidberg" src="images/zoidberg-knitting.gif" alt="">
				</section>

				<section>when should I refactor my code?</section>

				<section>
					<img src="images/refactor-haiku.png" />
					<a href="https://twitter.com/erinfranmc/status/1182313928539418624">https://twitter.com/erinfranmc/status/1182313928539418624</a>
					<div class="notes">
						no doubt this woman on twitter received a million recommendations of how she should have done better testing or something
						but refactoring is inherently risky
						not just that you can break stuff
						you might inadvertedently change some behaviour (eg it might have been broken and you might accidently fix it)
						changes can surprise users, might even break workflows
					</div>
				</section>

				<section>
					two situations where i would refactor
					<ol>
						<li>there's a bug and i'm trying to fix it</li>
						<li>i need to add a new feature, and I can't do it without touching this code</li>
					</ol>
					which is really just one reason 
					<div>i need to touch the code for some other reason</div>
					<div class="notes">
						michael feathers: 
							- redesigning the system (which is really just refactoring at a higher level)
							- optimisation, which is like fixing a bug (the thing doesn't work how we want)
						and definitely riff on the 4 reasons to leave home advertising for this one
					</div>
				</section>

				<section>
					1. do the refactor, ensuring no behaviour changes
					2. make the change
				</section>

				<section>
					how do I ensure I haven't changed anything?
				</section>

				<section>
					characterisation tests
					<div class="notes">
						put the shine effect on this for surprise
						and put a reference in to the book
						also probably read the book
						also maybe mention that we're talking about a code base where the test coverage isn't 100%
					</div>
				</section>

				<section>
					- assume the code is correct. DON'T CHANGE THE CODE
					- use tests to determine what the actual behaviour of the code is`
					- then the tests form documentation of the code yay
				</section>

				<section>
					<pre><code>
import format from 'date-fns/format';

export const formatShortDate = (timestamp: number | string = ''): string => {
	if (!timestamp) {
		return '';
	}

	return format(new Date(timestamp), 'yyyy-MM-d');
};						
					</code></pre>
					<div class="notes">
						go to live code example

						but would you really do all this?
						- it depends
						- it's a small bit of code, so it might be easier to just think it through
						- dates are tricky & this was easier than going through the dayjs docs
						- how much effort are the tests and how big is the risk of changing?
					</div>
				</section>

				<section>
					What about JSX?
				</section>

				<section>
					<pre><code>
function DayOfTheWeekWidget({ date = '' }: { date?: string | number }) {
	if (!date) {
		return <div>No date entered</div>
	}

	const formattedDate = formatShortDate(date)
	const dayOfTheWeek = format(new Date(date), 'EEEE')

	return <div>{formattedDate} is a {dayOfTheWeek}</div>
}						
					</code></pre>
					<div class="notes">
						- imagine we've got the same thing, but in a component 
						- two options: normal tests or snapshot tests
					</div>
				</section>

				<section>
					demo normal tests 
				</section>

				<section>
					describe snapshot tests 
				</section>

				<section>
					demo snapshot tests 
				</section>

				<section>
					snapshot tests cautionary tale 
				</section>

				<section>
					when snapshot tests are't going to work
				</section>


				<section>
					<pre><code>
	const LendingLink = ({ customerToken, routingCategory }: Props) => {
		if (routingCategory !== '[BORROWING_CASH]' || !customerToken) {
			return null;
		}
		
		return (
			<>
				<StyledDt>Lending Page</StyledDt>
				<StyledDd>
					<a
						href={`/customer/${customerToken}/lending`}
						rel="noopener noreferrer"
						target="_blank"
					>
						[Lending Page]
					</a>
				</StyledDd>
			</>
		);
	};
						 
					</code></pre>
					<div class="notes">
						describe what the code does
					</div>
				</section>

				<section>
					<pre><code>
describe('LendingLink', () => {
	const getTitle = () => screen.queryByText('Lending Page')
	
	const setup = (customerToken: string, routingCategory: string) => 
		render(
				<LendingLink customerToken={customerToken} routingCategory={routingCategory} />3
		)
	}
	
	it('displays ¯\_(ツ)_/¯ if routing category isn\'t BORROWING_CASH', () => {
		setup('C_12345', 'BAD_ROUTING_CATEGORY')
		expect(getTitle()).toBe('¯\_(ツ)_/¯')
	})
	
	it('displays ¯\_(ツ)_/¯ if customer token is blank', () => {
		setup('', 'BORROWING_CASH')
		expect(getTitle()).toBe('¯\_(ツ)_/¯')
	})
	
	it('displays ¯\_(ツ)_/¯ with a valid routing category and customer token', () => {
		setup('C_234567', 'BORROWING_CASH')
		expect(getTitle()).toBe('¯\_(ツ)_/¯')
	})
})						 
					</code></pre>
					should probably show how these fail
					<div class="notes">
						we can write tests using queries, just like we would in any other situation
					</div>
				</section>

				<section>
					<pre><code>
describe('LendingLink', () => {
	const getTitle = () => screen.queryByText('Lending Page')
	
	const setup = (customerToken: string, routingCategory: string) => {
		render(
				<LendingLink customerToken={customerToken} routingCategory={routingCategory} />
		)
	}
	
	it('doesn\'t display if routing category isn\'t BORROWING_CASH', () => {
		setup('C_12345', 'BAD_ROUTING_CATEGORY')
		expect(getTitle()).not.toBeInTheDocument()
	})
	
	it('doesn\'t display if customer token is blank', () => {
		setup('', 'BORROWING_CASH')
		expect(getTitle()).not.toBeInTheDocument()
	})
	
	it('displays the link', () => {
		setup('C_234567', 'BORROWING_CASH')
		expect(getTitle()).toBeInTheDocument()
	})
})
					</code></pre>
					<div class="notes">
						then we can figure out our passing tests
					</div>
				</section>

				<section>
					but also snapshot tests are a thing. 
					what even are snapshot tests.
				</section>

				<section>
					<pre><code>
describe('LendingLink', () => {

	const setup = (customerToken: string, routingCategory: string) => {
			const { asFragment } = render(
					<LendingLink customerToken={customerToken} routingCategory={routingCategory} />
			)
			return asFragment
	}

	it('doesn\'t display if routing category isn\'t BORROWING_CASH', () => {
			const fragment = setup('C_12345', 'BAD_ROUTING_CATEGORY')
			expect(fragment()).toMatchSnapshot()
	})

	it('doesn\'t display if customer token is blank', () => {
			const fragment = setup('', 'BORROWING_CASH')
			expect(fragment()).toMatchSnapshot()
	})
	
	it('displays the link', () => {
			const fragment = setup('C_234567', 'BORROWING_CASH')
			expect(fragment()).toMatchSnapshot()
	})
})					 
					</code></pre>
					highlight the different setup and stuff
					<div class="notes">
						don't even need the whole two-step process. snapshots are just it
					</div>
				</section>

				<section>
					we want to change the styling, but leave the HTML alone,
					then a snapshot test is going to be nice and quick
					check whether it changes the class name for the styled components
				</section>

				<section>
					we want to change the HTML structure because the page isn't set up as a definition list anymore 
					snapshot tests are going to be a bit rubbish for that, use queries
				</section>

				<section>
					// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`UpperLimitOverrideConfirmationDialog UpperLimitOverrideConfirmationDialog can render 1`] = `<DocumentFragment />`;

					snapshot tests gotcha: empty snapshot!
					<div class="notes">
						Again, this is a pretty simplified example, so next let's have a look at something a bit more complex
						(not something from the real world because these code samples are from the real world)
					</div>
				</section>

				<section>
					intro to socialite
				</section>

				<section>
					new requirements!

					Add stocks to payment type radio buttons
Change label of amount field to show stocks + stocks limit
Don’t do currency conversion when stocks amount is updated
Show stocks limit in maximum amount per payment switch
Show calendar year amount override switch in USD
Call new stocks API
Update amount paid in session to also show stocks
Don’t show the BTC conversion widget when stocks are selected

<div class="notes">
	this is a pretty hefty bit of work that we probably don't want to do all in one go 
	could use a feature flag to hide the new radio button while we develop everything else
	but this is a 45-minute talk, ain't got no time for feature flags, we're just going to start by
	building the second thing, and rely on our automated tests to tell us if we've got things right, 
	rather than testing locally in an actual browser
</div>
				</section>

				<section>
					updated label needs to look like
					Stocks Amount <amount in input> (min $<stocks min>, max $<stocks max>)
<div class="notes">
	we can implement this and be pretty sure that it's going to look ok, without needing to actually look at it
	but...
</div>
				</section>

				<section>
					...the current code looks like ... 
					separate labels for each option. actually maybe even separate inputs
					<div class="notes">
						it's relying on bits of state from all over the component
						how are we going to test it without writing the radio button part first?
					</div>
				</section>

				<section>
					Create a new component!
					<pre><code>
						export default function AmountLabel({currency, amount, minAmount, maxAmount}: Props) {
  
							...
					 
						return <label htmlFor="amount">{currency} Amount {amount} (min {minAmount}, max {maxAmount})</label>
					 
					 }
					 
					</code></pre>
					<div class="notes">
						creating a whole new component feels like a risky change though, so how do we do it safely?
					</div>
				</section>

				<section>
					1. write characterisation tests for current behaviour of the label
					2. refactor into a new label component, and ensure the behaviour is unchanged
					3. write tests for our new functionality
					4. write the new functionality
				</section>

				<section>
					Step 1. Test the existing functionality
					<pre><code>
it('shows ¯\\_(ツ)_/¯ when the currency is USD', ...)
it('shows ¯\\_(ツ)_/¯ when the currency is Bitcoin', ...)
it('shows ¯\\_(ツ)_/¯ when the amount changes', ...)
it('show ¯\\_(ツ)_/¯ when the upper limit changes', ...)
					</code></pre>

				</section>

				<section>
					Step 2. Extract the functionality into a component
					<pre><code>
						<AmountLabel
 currency={this.state.currency}
 amount={this.state.amount}
 minAmount={LOWER_LIMIT[this.state.currency]}
 maxAmount={this.state.upperLimit}
/>

					</code></pre>
				</section>

				<section>
					Step 2 (cont). Extract the functionality into a component
					<pre><code>
						export default function AmountLabel({currency, amount, lowerLimit, upperLimit}: Props) {
							const getLabelText = (): string => {
								switch (currency) {
									case PayoutCurrency.USD:
										return `USD Amount ${amount.toLocaleString()} (min $${lowerLimit}, max $${upperLimit})`
									case PayoutCurrency.BTC:
										return `Satoshi Amount ${formatNumber(amount)} (min ${formatNumber(
											lowerLimit
										)} satoshi, max ${formatNumber(upperLimit)} satoshi)`
									default:
										return "Amount"
								}
							}
						 
							return <label htmlFor="amount">{getLabelText()}</label>
						 
						 }
						 
					</code></pre>
				</section>

				<section>
					Step 3a. Write tests for our new functionality.

					Maybe we want to refactor our existing tests a bit first
				</section>

				<section>
					Step 3b. Actually write our tests
				</section>

				<section>
					Step 4. Add the new functionality
				</section>

				<section>
Add stocks to payment type radio buttons
<s>Change label of amount field to show stocks + stocks limit</s>
Don’t do currency conversion when stocks amount is updated
Show stocks limit in maximum amount per payment switch
Show calendar year amount override switch in USD
Call new stocks API
Update amount paid in session to also show stocks
Don’t show the BTC conversion widget when stocks are selected

					<div class="notes">
						sweet, so that's one thing crossed off the list
						the next thing literally says _don't_ do a thing, so we shouldn't have to do anything, right?
					</div>
				</section>

				<section>
					<pre><code>
						private convertAmountCents(
 amountCents: number,
 sourceCurrency: string,
 convertedAmountCents: { [customerRegion: string]: number }
) {
 // Do not send request when amountCents == 0
 if (amountCents == 0) {
   for (const customerRegion in convertedAmountCents) {
     convertedAmountCents[customerRegion] = 0
   }
   this.setState({
     convertedAmountCents: convertedAmountCents
   })
   return
 }

 // Do not send request when currency == BTC
 if (sourceCurrency == "BTC") return
					</code></pre>
					<div class="notes">
						the code checks for BTC and returns early, rather than checking for the existence of USD and doing the thing
					</div>
				</section>

				<section>
					<pre><code>if (sourceCurrency == "BTC" || sourceCurrency == "STOCKS") return</code></pre>
					<div class="notes">
						we could just add stocks to the btc check and be done with it
						and, if we were in a hurry, maybe that's what we would do
						but i like my code tested!
					</div>
				</section>

				<section>
<pre><code>
	<NumericInput 
		onValueChange={this.handleAmountChange}
		min={0}
		placeholder={"0"}
		allowNumericCharactersOnly={true}
		minorStepSize={null}
		buttonPosition={"none"}
		fill={true}
	/>
	{!this.isAmountValid(this.state.amountCents) && (
		<label style={{ color: Colors.RED3 }}>Invalid Amount</label>
	)}
	{this.state.currency != "BTC" && 
		this.state.convertedAmountCents.GBP >= 0 && (
			<label style={{ color: Colors.GREEN3 }}>wavy equals pound sign{this.state.convertedAmountCents.GBP / 100}</label>
		)
	{this.state.currency != "BTC" && 
		this.state.convertedAmountCents.GBP < 0 && (
			<label style={{ color: Colors.RED3 }}>
				Failed to convert amount to GBP, will pay UK customers in USD!
			</label>
		)}
	)}
</code></pre>
					<div class="notes">
						and this != BTC check actually happens in quite a few places, so it would be nice to clean it up a bit
					</div>
				</section>

				<section>
					go through same process 
					characterisation tests, extract to component, refactor tests, add new functionality
				</section>

				<section>
					characterisation tests
				</section>

				<section>
					extract to component, that will look something like 
					<pre><code>
						<AmountInput currency={} minAmount={} maxAmount={} handleAmountUpdate={} />
					</code></pre>
					and if we think back to what we just did, we made a component like
					<pre><code>
						<AmountLabel
						currency={this.state.currency}
						amount={this.state.amount}
						minAmount={LOWER_LIMIT[this.state.currency]}
						maxAmount={this.state.upperLimit}
					 />
					 
					</code></pre> 
					and those are pretty similar
					something something single responsibility principle
					yadda yadda one reason to change 
					these should be the same component
				</section>

				<section>
					there's actually a fairly big chunk involved in moving this stuff
					so should probably go through it step by step
				</section>

				<section>
					when refactoring the tests, don't forget that we need to test that 
					the handler gets called
				</section>

				<section>
					What did we learn?
					- refactor code when we're touching it
					- use characterisation tests to ensure we don't change functionality
					- extract functionality into components to isolate and test 
					- group similar concerns into components

				</section>

				<section class="end">
					<style>
						.end {
							font-family: Futurama;
							align-items: center;
						}

						.end .bender {
							position: fixed;
						}
					</style>

					<div class="fragment"><a href="https://refactor.ez.codes">https://refactor-tractor.ez.codes</a></div>	

					<div class="fragment">
						<div>@ErinJZimmer</div>
						<div>Thank you!</div>
					</div>


					<img src="images/bender-applause.png" alt="bender holding applause sign" class="bender fragment">
				</section>
			</div>
		</div>

		<div style="position: fixed; bottom: 30px; right: 30px; font-family: Futurama; font-size: 36px; opacity: .6; z-index: 1">
			@ErinJZimmer
		</div>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				controls: false,
				history: true,
				display: 'grid',
				progress: false,
				transition: 'fade',
				center: false,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});

		</script>
	</body>
</html>
