<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Getting on the Refactor Tractor</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">
		<link rel="stylesheet" href="css/fonts.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<script src="js/reveal.js"></script>

		<style>
			* {
				box-sizing: border-box;
			}

			body {
				--dark-blue: hsl(202, 69%, 15%);
				--light-blue: #15A9DD;
				--light-orange: hsl(19, 87%, 62%);
				--dark-orange: hsl(24, 100%, 38%);
				--light-red: hsl(0, 94%, 41%);
				--red: #7B0001;
				--shadow: hsl(202, 69%, 15%, .4);
				--green: hsl(125, 94%, 41%);
				--dark-green: hsl(125 94% 20%);
				--gradient-start: hsl(259, 71%, 80%);
				--gradient-end: hsl(265, 58%, 50%);
				--yellow: #F2E34B;
			}

			.notes {
				display: none;
			}
			pre, .browser {
				-moz-tab-size: 2;
				border: 4px solid hsl(200, 10%, 55%);
				border-top-width: 32px;
				border-radius: 10px;
				padding: .5em;
				background: #272822;
				box-shadow:
					inset 2px 2px 1px black,
					4px 4px 8px hsla(0, 0%, 20%, .3);
				align-self: center;
			}
			pre code {
				border-radius: 10px;
				height: 100%;
			}

			h1 {
				font-size: 60px;
			}

			ul {
				list-style-type: '\1f680';
			}
			li {
				margin: .75em 0;
				padding-left: .5em;
			}

			.shadow {
				box-shadow: 1px 1px 4px hsla(0, 0%, 70%), 3px 3px 6px hsla(0, 0%, 70%);
			}

			.reveal .slides > section.auto-height {
				height: auto;
			}

			.fragment.transient {
				display: none;
			}
			.fragment.transient.current-fragment {
				display: block;
			}

		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

				<section class="title" data-background-image="images/img_hero.jpg">
					<h1 style="width: 50%;font-size: 3em">Getting on the refactor tractor</h1>
				</section>

				<section class="intro">
					<style>
						.intro {
							grid-template-rows: min-content min-content 60%;
							align-content: center;
						}
						.intro a {
							text-align: left;
							align-self: center;
							font-weight: bold;
						}
						.intro .zoidberg {
							position: fixed;
							left: 644px;
							top: 379px;
							border-radius: 62% 38% 63% 37% / 73% 52% 48% 27%;
						}

						.intro .logos {
							list-style: none;
							display: grid;
							grid-template-columns: 1fr 1fr;
							max-width: 60%;
							margin: 0;
							grid-gap: 40px;
							align-items: center;
						}
						.intro .logos li {
							margin: 0;
						}
					</style>
					<div style="justify-self: left; font-family: Futurama;">@ErinJZimmer</div>
					<a href="https://layouts.ez.codes">https://layouts.ez.codes</a>
					<ul class="logos">
						<li><img src="images/cogent-logo.svg" alt=""></li>
						<li><img src="images/gde-logo.png"></li>
					</ul>
					<img class="zoidberg" src="images/zoidberg-knitting.gif" alt="">
				</section>

				<section>what is refactoring? </section>

				<section>
					example of IDE refactoring code
					splitting class or function into smaller pieces 
					renaming things 
					moving repeated code into reusable functions 
					mention the refactoring book and its long index of refactors 
				</section>

				<section>
					when to refactor?
					everything is tradeoffs
					refactoring is very satisfying and can provide a lot of value
					- faster development (easier to work in parallel, get people up to speed faster, easier to understand code)
					- more confidence because it's easier to understand the code, easier to have better test coverage
					but there are downsides

					put the damn socialite time period picker code
				</section>

				<section>
					refactoring is inherently risky - you might break something
					<img src="images/refactor-haiku.png" />
					<a href="https://twitter.com/erinfranmc/status/1182313928539418624">https://twitter.com/erinfranmc/status/1182313928539418624</a>
					<div class="notes">
						no doubt this woman on twitter received a million recommendations of how she should have done better testing or something
						but refactoring is inherently risky
						not just that you can break stuff
						you might inadvertedently change some behaviour (eg it might have been broken and you might accidently fix it)
						changes can surprise users, might even break workflows
					</div>
				</section>

				<section>
					or you might fix something! 
					unexpected change can be bad, depending on your product/industry
				</section>

				<section>
					refactoring isn't free 
					is there something more valuable you could be doing with your time? 
					a day of refactoring is nice for you, but the users don't notice it
				</section>

				<section>
					there's no magic answer - you have to weigh up the risks, cost and value yourself
					as a rule though, i only refactor code that i'm either touching immediately, or that 
					i know someone is going to touch very soon 
					ie the value is certain
					scrolled past the damn socialite code for 2 months without refactoring it because 
					it worked, and there was no value in changing it
				</section>

				<section>
					so you've decided to refactor

					you've spent 3 days fighting bugs because you keep forgetting moment dates are mutable 
					the library was deprecated x years ago and is probably full of security issues
					it's time to replace it with dayjs 

					value is high - date stuff is going to be easier in the future + security patches whatever 
					cost is relatively low because this codebase has wrapper functions around the calls to 
					format, so we only need to change half a dozen wrapper functions instead of updating every single 
					date in the app!
				</section>

				<section>
					the date function

					so how do we manage the risk?
				</section>

				<section>
					1. use testing to determine the current behaviour of the system 
					2. do the refactor, using the tests to ensure the behaviour doesn't change 
					3. make changes (in this case nothing - the refactor is the entire point)
				</section>

				<section>
					use a special kind of test: characterisation tests. whathisname and his book.
					even if your codebase already has good test coverage, you might want to consider adding 
					some characterisation tests
					if your codebase doesn't have good test coverage, you definitely want some of these.
				</section>

				<section>
					normal test. 
					invariable behaviour encoded in test 
					write code until the test passes 

					or, if you don't do TDD
					write some code 
					write your test 
					go back and change your code until the test passes 
					consider your life choices and how much time you would have saved if you just wrote the test first 
				</section>

				<section>
					characterisation test 
					invariable behaviour encoded in code 
					change the tests until they pass 

					important point in both cases: we change the code OR we change the tests, never both

					do the live code example 
					you'll have to decide what to do about the difference in behaviour between the libraries

					but would you really do all this?
					- it depends
					- it's a small bit of code, so it might be easier to just think it through
					- dates are tricky & this was easier than going through the dayjs docs
					- how much effort are the tests and how big is the risk of changing?
				</section>

				<section>
					What about JSX?
				</section>

				<section>
					<pre><code>
function DayOfTheWeekWidget({ date = '' }: { date?: string | number }) {
	if (!date) {
		return <div>No date entered</div>
	}

	const formattedDate = formatShortDate(date)
	const dayOfTheWeek = format(new Date(date), 'dddd')

	return <div>{formattedDate} is a {dayOfTheWeek}</div>
}
											</code></pre>
					<div class="notes">
						- continuing with our moment to dayjs refactor, we can take the same approach as before...
					</div>
				</section>

				<section>
					Snapshot Tests 
				</section>

				<section>
					<pre><code>
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`DayOfTheWeekWidget renders ?? when passed an empty string 1`] = `
<div>
	<div>
		No date entered
	</div>
</div>
`;
</code></pre>
					<div class="notes">
						- first run: create snapshot 
						- subsequent runs, compare to snapshot

						Demo 
						- write snapshot tests 
						- show snapshot being written & in folder
						- refactor to dayjs (new format is 'dddd')
					</div>
				</section>

				<section>
					snapshot tests cautionary tale 
				</section>

				<section>
					when snapshot tests aren't going to work

					embed the example here so i can demo the enter + space
				</section>

				<section>
					<div>
						<button id="open-modal">Open modal</button>
						<div id="modal" style="opacity: 0">
							<p>Can we fix it?</p>
							<div>
								<button id="confirm-button" onClick={onConfirm}>Yes, we can!</button>
								<a id="cancel-button" onClick={handleCancel} onKeyDown={handleSpace} href="#">No, we can't</a>
							</div>
						</div>
						<script>
							const openModal = document.getElementById('open-modal')
							const modal = document.getElementById('modal')
							const confirmButton = document.getElementById('confirm-button')
							const cancelButton = document.getElementById('cancel-button')

							openModal.addEventListener('click', () => {	
								modal.style.opacity = 1
							})
							confirmButton.addEventListener('click', () => {
								modal.style.opacity = 0
							})
							cancelButton.addEventListener('click', (event) => {
								modal.style.opacity = 0
								event.preventDefault()
							})
						</script>	
					</div>
				</section>

				<section>
<pre><code class="jsx">
	export function ConfirmationModal({ onConfirm, onCancel }) {
	
		const handleCancel = (event) => {
			event.preventDefault();
			onCancel();	
		}
	
		const handleSpace = (event) => {
			const keyPressed = event.code
			if (keyPressed === 'Space') {
				handleCancel(event);
			}
		}
		
		return (
			<div>
				<p>Can we fix it?</p>
				<div>
					&lt;button onClick={onConfirm}>Yes, we can!</button>
					&lt;a
						onClick={handleCancel} 
						onKeyDown={handleSpace} 
						href="#"
					&gt;No, we can't</a>
				</div>
			</div>
		)
	}					
</code></pre>
				<div class="notes">
					- look at example with snapshot test 
					problems
						- we need to change the HTML, which is going to cause the snapshot test to fail
						- its only testing the render, not the actual behaviour
						- can't test the behaviour because it's not causing the render to change 
					outcome
						- use query tests to test behaviour 
						- use correct semantic HTML and throw out a heap of code & tests
						  (we don't need tests when we use semantic HTML because we meet the standard 
							by default. if the standard changes, the behaviour of our app will too, which 
							is what we want. but also, the behaviour will just work in unknown media eg 
							touch screens, non-standard inputs)
				</div>				
				</section>

				<section>
					the refactored code but we'll need to put in the styling to make it match
				</section>

				<section>
					Snapshot tests 
						- when the HTML isn't going to change 

					Query tests 
						- when the HTML is going to change
						- when testing behaviour not reflected in HTML
				</section>

				<section>
					intro to ye olde farm shop
					but go on, put a thorn in and explain the y thing
				</section>

				<section>
					new requirements!

					- Add plant product type to radio buttons
					- Show plant unit price + total price in label 
					- Calculate postage for plants
<div class="notes">
	- not a huge bit of work, but it's nice to be able to break it down, especially as we'll need to write 
		some tests to cover the existing behaviour and the PR could get quite big 
	- instead we'll do each step individually, but not in the order they're given here: the new radio button 
	  relies on the other two things, so we can't merge it until those are complete, so let's do the other two 
		first
</div>
				</section>

				<section>
					1. Show plant unit price + total price in label 
					2. Calculate postage for plants 
					3. Add new radio button

					<div class="notes">
						update label - do live code 
						- note the repeated code & logic all over the place
						- wouldn't it be simpler if it was all encapsulated in a single component?
						- write tests for seed & seedling that select the product from radio button 
						- create new component, figure out what the props are, simplify the code 
						- plug in new component and check the tests still work
						- copy existing tests over and simplify for new component 
						- write test for new functionality 
						- write new functionality 
						- what do we do with the old test? well, we probably want one that checks that the label is hooked up right 
						  ie if i click the radio button, the label changes
					</div>
				</section>

				<section>
					What we just did 
					1. wrote characterisation tests for existing behaviour (so we're confident we know what the code should do)
					2. refactored into new component (so it's easier to work with)
					3. tested new component with existing tests (so we're sure our refactor was successful)
					4. refactored tests (so they're easier to work with)
					5. wrote tests for new feature (because TDD)
					6. wrote new feature (yay!)
				</section>

				<section>
					<strike>1. Show plant unit price + total price in label</strike>
					2. Calculate postage for plants 
					3. Add new radio button
					<div class="notes">
						- write tests for current postage behaviour - it's complicated!
							- when product type is seed, when it changes to seedling, when count changes & its seed,
							  when count changes and its seedling
						- extract JSX to new component & simplify
						- extract to new hook 
						- write hook tests 
						- write tests for new component 
						- delete the old tests
					</div>
				</section>

				<section>
					<strike>1. Show plant unit price + total price in label</strike>
					<strike>2. Calculate postage for plants</strike>
					3. Add new radio button
					<div class="notes">
						- one other small refactor before moving on
					</div>
				</section>

				<section>
					CountLabel and the input are closely related implicitly 
					CountLabel explicitly depends on count, but implicitly depends on the id of the input 
					also, different levels of abstraction 
					I would put them into a component together
				</section>

				<section>
					<strike>1. Show plant unit price + total price in label</strike>
					<strike>2. Calculate postage for plants</strike>
					3. Add new radio button
					<div class="notes">
						which just leaves one last thing
						radio button is already its own component, which is nice 
						we're changing the code, so let's write some tests 
						- each possible scenario because each thing is its own bit of code
						- once we have the tests we can refactor it so there's just one bit of code no matter the product 
						- then we don't need all those tests, because the same bit of code is executing no matter than config
						finally, we can add our new product type
						- we could write tests, but we're not really testing anything other than what's already there - test 
						wouldn't really be adding value
					</div>
				</section>

				<section>
					finished product
				</section>

				<section>
					what we did 
					- wrote characterisation tests for existing functionality 
					- broke existing features out into independent, testable components 
					- refactored tests to specific components: leads to more valuable tests 
					because they pinpoint the problem efficiently, but also keep some of the top 
					level tests for testing integration between ProductTypeSelector and ProductCount 
					(should probably improve the postage integration test)
					- TDDed our new features easily, because components, existing tests etc 
					- Merged components together that shared common concerns

					- left with a nice modular app with tests that explain what each part does,
					and each part only doing one thing
				</section>

				<section>
					What did we learn?
					- balance the cost, risk and value of refactoring before starting
					- use characterisation tests to ensure we don't change functionality: change the test or the code, not both
					- if a thing needs to be tested in isolation, it should be its own component/function 
					- if things have implicit connections, they should be in the same component
				</section>

				<section class="end">
					<style>
						.end {
							font-family: Futurama;
							align-items: center;
						}

						.end .bender {
							position: fixed;
						}
					</style>

					<div class="fragment"><a href="https://refactor.ez.codes">https://refactor-tractor.ez.codes</a></div>	
					code example also

					<div class="fragment">
						<div>@ErinJZimmer</div>
						<div>Thank you!</div>
					</div>


					<img src="images/bender-applause.png" alt="bender holding applause sign" class="bender fragment">
				</section>
			</div>
		</div>

		<div style="position: fixed; bottom: 30px; right: 30px; font-family: Futurama; font-size: 36px; opacity: .6; z-index: 1">
			@ErinJZimmer
		</div>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				controls: false,
				history: true,
				display: 'grid',
				progress: false,
				transition: 'fade',
				center: false,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});

		</script>
	</body>
</html>
